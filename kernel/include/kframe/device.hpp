#pragma once
#include"device.h"
#include <kutil/dbg.h>
namespace msddk { ;

CDevice::CDevice(DEVICE_TYPE DeviceType,
	const wchar_t *pwszDeviceName,
	ULONG DeviceCharacteristics,
	bool bExclusive,
	ULONG AdditionalDeviceFlags)
{
	if (pwszDeviceName)
		m_DeviceName = pwszDeviceName;

	m_DeviceCharacteristics = DeviceCharacteristics;
	m_pNextDevice = NULL;
	m_bExclusive = bExclusive;
	m_bDeletePending = false;
	m_bInterfaceEnabled = false;
	m_pDeviceObject = NULL;
	m_DeviceType = DeviceType;
	m_pUnderlyingPDO = NULL;
	m_AdditionalDeviceFlags = AdditionalDeviceFlags;
	m_pDriver = NULL;

	memset(&m_InterfaceName, 0, sizeof(m_InterfaceName));
}

CDevice::~CDevice()
{
}

bool CDevice::Valid()
{
	return (m_pDeviceObject != NULL);
}

NTSTATUS CDevice::CreateDevice(CDriver *pDriver, bool bCompleteInitialization/* = true*/, const wchar_t *pwszLinkPath/* = NULL*/)
{
	UNREFERENCED_PARAMETER(pDriver);
	UNREFERENCED_PARAMETER(bCompleteInitialization);
	UNREFERENCED_PARAMETER(pwszLinkPath);

	if (m_DeviceName.IsEmpty() )
	{
		if ( GetDeviceName())
		{
			m_DeviceName = GetDeviceName();
		}
	}

	if ( !pwszLinkPath )
	{
		m_LinkName += pwszLinkPath;
	}
	if ( m_LinkName.IsEmpty() )
	{
		if ( GetDeviceLinkName() )
		{
			m_LinkName += GetDeviceLinkName();
		}
	}

	if (m_pDeviceObject)
		return STATUS_ALREADY_REGISTERED;

	if (!pDriver)
		pDriver = CDriver::GetMainDriver();

	if (!pDriver)
		return STATUS_INTERNAL_ERROR;

	


	NTSTATUS st = STATUS_SUCCESS;
	CKeStringW FullDevicePath;
	CKeStringW LinkName;
	if ( m_LinkName )
	{
		LinkName = L"\\DosDevices\\";
		LinkName += m_LinkName;
	}


	if (m_DeviceName.Length())
	{
		FullDevicePath = L"\\Device\\";
		FullDevicePath += m_DeviceName;
	}

	if (LinkName.Length() && FullDevicePath.IsEmpty())
		return STATUS_OBJECT_NAME_INVALID;

	if (FullDevicePath.IsEmpty())
		m_DeviceCharacteristics |= FILE_AUTOGENERATED_DEVICE_NAME;

	st = IoCreateDevice(pDriver->m_DriverObject,
		sizeof(Extension),
		FullDevicePath,
		m_DeviceType,
		m_DeviceCharacteristics,
		m_bExclusive,
		&m_pDeviceObject);

	if (!NT_SUCCESS(st))
	{
		KdPrint(("Device::CreateDevice(): failed call to IoCreateDevice() (%d)\n", st));
		return st;
	}

	m_pDeviceObject->Flags |= m_AdditionalDeviceFlags;
	Extension *pExt = (Extension *)m_pDeviceObject->DeviceExtension;
	pExt->Signature = Extension::DefaultSignature;
	pExt->pDevice = this;
	if (LinkName.Length())
	{
		st = IoCreateSymbolicLink(LinkName, FullDevicePath);
		if (!NT_SUCCESS(st))
		{
			KdPrint(("failed call to IoCreateSymbolicLink(%ws,%ws) (%wS)\n", LinkName.GetBuffer(),FullDevicePath.GetBuffer(), MapNTStatus(st)));
			
			m_LinkName.Empty();
		}
	}

	if (bCompleteInitialization)
		CompleteInitialization();

	m_pDriver = pDriver;
	st = OnAfterCreate();
	if ( !NT_SUCCESS(st) )
	{
		KdPrint(("Device::CreateDevice(): failed call to OnAfterCreate() (%wS)\n", MapNTStatus(st)));
		return st;
	}
	pDriver->OnDeviceRegistered(this);
	return STATUS_SUCCESS;
}

NTSTATUS CDevice::DeleteDevice(bool FromIRPHandler)
{
	UNREFERENCED_PARAMETER(FromIRPHandler);
	KdPrint(("CDevice::DeleteDevice\n"));
	NTSTATUS st = OnBeforeDelete();
	if ( !NT_SUCCESS(st) )
	{
		KdPrint(("Device::CreateDevice(): failed call to OnBeforeDelete() (%wS)\n", MapNTStatus(st)));
	}

	m_bDeletePending = true;
	if (m_pDeviceObject)
	{
		if (m_LinkName.Length())
		{
			CKeStringW LinkName = L"\\DosDevices\\";
			LinkName += m_LinkName;
			IoDeleteSymbolicLink(LinkName);
		}
			

		if (m_InterfaceName.Buffer)
		{
			RtlFreeUnicodeString(&m_InterfaceName);
			memset(&m_InterfaceName, 0, sizeof(m_InterfaceName));
		}

		if (m_pNextDevice)
			DetachDevice();

		IoDeleteDevice(m_pDeviceObject);
		m_pDeviceObject = NULL;
	}

	m_bDeletePending = false;
	
	if (m_pDriver)
		m_pDriver->OnDeviceUnregistered(this);

	return STATUS_SUCCESS;
}

NTSTATUS CDevice::ProcessIRP(IN PIRP  Irp, bool bIsPowerIrp)
{
	UNREFERENCED_PARAMETER(Irp);
	UNREFERENCED_PARAMETER(bIsPowerIrp);

	//KdPrint(("ProcessIRP\n"));
	if (!m_pDeviceObject)
		return STATUS_INVALID_DEVICE_STATE;

	PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
	IncomingIrp incomingIrp(Irp,
		bIsPowerIrp,
		bIsPowerIrp && ((IrpSp->MinorFunction == IRP_MN_QUERY_POWER) || (IrpSp->MinorFunction == IRP_MN_SET_POWER)));
	
	NTSTATUS st = DispatchRoutine(&incomingIrp, IoGetCurrentIrpStackLocation(Irp));
	return PostProcessIRP(&incomingIrp, st, false);
}

NTSTATUS CDevice::PostProcessIRP(IncomingIrp *pIrp, NTSTATUS ProcessingStatus, bool FromDispatcherThread)
{
	if (ProcessingStatus == STATUS_PENDING)
	{
		ASSERT(pIrp->m_Flags & IncomingIrp::IrpMarkedPending);
		return ProcessingStatus;
	}

	ASSERT(!(pIrp->m_Flags & IncomingIrp::IrpMarkedPending));
	if (pIrp->m_Flags & (IncomingIrp::LowerDriverCalled | IncomingIrp::IrpCompleted))
	{
		if (!(pIrp->m_Flags & IncomingIrp::IrpCompleted))
			pIrp->CompleteRequest();
	}
	else
	{
		if (FromDispatcherThread)
		{
			ProcessingStatus = ForwardPacketToNextDriverWithIrpCompletion(pIrp);
			/*ProcessingStatus = CallNextDriverSynchronously(pIrp);
			pIrp->CompleteRequest();*/
		}
		else
			ProcessingStatus = ForwardPacketToNextDriver(pIrp);
	}

	return ProcessingStatus;
}


NTSTATUS CDevice::ForwardPacketToNextDriver(IN IncomingIrp *Irp)
{
	if (!m_pNextDevice)
	{
		NTSTATUS st = Irp->m_pIrp->IoStatus.Status;
		Irp->CompleteRequest();
		return st;
	}
	else
	{
		InterlockedOr(&Irp->m_Flags, IncomingIrp::LowerDriverCalled);
		if (Irp->m_Flags & IncomingIrp::StartNextPowerIrp)
			PoStartNextPowerIrp(Irp->m_pIrp);
		IoSkipCurrentIrpStackLocation(Irp->m_pIrp);
		if (Irp->m_Flags & IncomingIrp::IsPowerIrp)
			return PoCallDriver(m_pNextDevice, Irp->m_pIrp);
		else
			return IoCallDriver(m_pNextDevice, Irp->m_pIrp);
	}
}

NTSTATUS CDevice::IrpCompletingCompletionRoutine(IN PDEVICE_OBJECT  DeviceObject, IN PIRP pIrp, IN PVOID Context)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Context);
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS CDevice::ForwardPacketToNextDriverWithIrpCompletion(IN IncomingIrp *Irp)
{
	NTSTATUS status;

	if (!m_pNextDevice)
		return STATUS_INVALID_DEVICE_REQUEST;

	InterlockedOr(&Irp->m_Flags, IncomingIrp::LowerDriverCalled);
	IoCopyCurrentIrpStackLocationToNext(Irp->m_pIrp);
	IoSetCompletionRoutine(Irp->m_pIrp, IrpCompletingCompletionRoutine,
		NULL, TRUE, TRUE, TRUE);

	if (Irp->m_Flags & IncomingIrp::IsPowerIrp)
		status = PoCallDriver(m_pNextDevice, Irp->m_pIrp);
	else
		status = IoCallDriver(m_pNextDevice, Irp->m_pIrp);
	return status;
}

NTSTATUS __forceinline CDevice::DispatchRoutine(IN IncomingIrp *Irp, IO_STACK_LOCATION *IrpSp)
{ 
	UNREFERENCED_PARAMETER(IrpSp);
	return Irp->GetStatus(); 
}

NTSTATUS CDevice::DetachDevice()
{
	if (!m_pDeviceObject)
		return STATUS_INVALID_DEVICE_STATE;

	if (!m_pNextDevice)
		return STATUS_INVALID_DEVICE_STATE;

	m_pUnderlyingPDO = NULL;
	IoDetachDevice(m_pNextDevice);
	m_pNextDevice = NULL;
	return STATUS_SUCCESS;
}
void CDevice::CompleteInitialization()
{
	if (m_pDeviceObject)
		m_pDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
}

NTSTATUS CDevice::RegisterInterface(IN CONST GUID *pGuid, IN PCUNICODE_STRING ReferenceString /*= NULL*/)
{
	if (!pGuid)
		return STATUS_INVALID_PARAMETER;
	if (!m_pUnderlyingPDO || m_InterfaceName.Buffer)
		return STATUS_INVALID_DEVICE_STATE;
	return IoRegisterDeviceInterface(m_pUnderlyingPDO, pGuid, (PUNICODE_STRING)ReferenceString, &m_InterfaceName);
}

NTSTATUS CDevice::EnableInterface()
{
	if (!m_InterfaceName.Buffer)
		return STATUS_INVALID_DEVICE_STATE;
	NTSTATUS st = IoSetDeviceInterfaceState(&m_InterfaceName, TRUE);
	if (NT_SUCCESS(st))
		m_bInterfaceEnabled = true;
	return st;
}

NTSTATUS CDevice::DisableInterface()
{
	if (!m_InterfaceName.Buffer)
		return STATUS_INVALID_DEVICE_STATE;
	NTSTATUS st = IoSetDeviceInterfaceState(&m_InterfaceName, FALSE);
	if (NT_SUCCESS(st))
		m_bInterfaceEnabled = false;
	return st;
}

NTSTATUS CDevice::AttachToDeviceStack(PDEVICE_OBJECT DeviceObject)
{
	if (!m_pDeviceObject)
		return STATUS_INVALID_DEVICE_STATE;
	if (!(m_pDeviceObject->Flags & DO_DEVICE_INITIALIZING))
		return STATUS_INVALID_DEVICE_STATE;
	if (m_pNextDevice)
		return STATUS_ALREADY_REGISTERED;
	m_pNextDevice = IoAttachDeviceToDeviceStack(m_pDeviceObject, DeviceObject);
	if (!m_pNextDevice)
		return STATUS_INVALID_DEVICE_STATE;
	m_pUnderlyingPDO = DeviceObject;
	return STATUS_SUCCESS;
}

NTSTATUS CDevice::AttachToDevice(CKeStringW DevicePath)
{
	if (!m_pDeviceObject)
		return STATUS_INVALID_DEVICE_STATE;
	if (m_pNextDevice)
		return STATUS_ALREADY_REGISTERED;
	NTSTATUS st = IoAttachDevice(m_pDeviceObject, DevicePath, &m_pNextDevice);
	if (!NT_SUCCESS(st))
		return st;
	if (!m_pNextDevice)
		return STATUS_INVALID_DEVICE_STATE;
	m_pUnderlyingPDO = m_pNextDevice;
	return STATUS_SUCCESS;
}

NTSTATUS CDevice::OnAfterCreate()
{
	KdPrint(("CDevice::OnAfterCreate()\n"));
	return STATUS_SUCCESS;
}

NTSTATUS CDevice::OnBeforeDelete()
{
	KdPrint(("CDevice::OnBeforeDelete()\n"));
	return STATUS_SUCCESS;
}


LPCWSTR CDevice::GetDeviceName()
{
	return NULL;
}

LPCWSTR CDevice::GetDeviceLinkName()
{
	return NULL;
}
};
